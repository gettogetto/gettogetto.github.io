> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [zhuanlan.zhihu.com](https://zhuanlan.zhihu.com/p/412102389)

本文主要 C++ 中 crash 解析定位原理，讨论为什么能解析出堆栈？如何找到函数名称？如何定位出 C++ 源文件的行号？crash 时寄存器值有什么意义？以及遇到 crash 时如何应对。最后就是常见 C++ 中 crash 案例分析，比如空指针 / 低地址访问，变量偏移确定；this 指针为空；空函数指针；虚函数调用问题；野指针及内存改写问题；除 0 错误及系统抛出 SIGABRT 及手动抛出异常。本文涉及同样 C++ 的代码在 Windows,Linux,Andorid,IOS 四个平台的讨论，除去基本原理相同，汇编层面表现时会有一定区别，具体差别不详细指出。

*   [C++ 中 Crash 定位原理与常见案例反汇编分析](https://zhuanlan.zhihu.com/p/412102389/edit#c%E4%B8%ADcrash%E5%AE%9A%E4%BD%8D%E5%8E%9F%E7%90%86%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%A1%88%E4%BE%8B%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90)
*   [一 概要](https://zhuanlan.zhihu.com/p/412102389/edit#%E4%B8%80-%E6%A6%82%E8%A6%81)
*   [二 crash 解析原理](https://zhuanlan.zhihu.com/p/412102389/edit#%E4%BA%8C-crash%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86)

*   [2.1 执行环境](https://zhuanlan.zhihu.com/p/412102389/edit#21-%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83)
*   [2.2 定位函数](https://zhuanlan.zhihu.com/p/412102389/edit#22-%E5%AE%9A%E4%BD%8D%E5%87%BD%E6%95%B0)
*   [2.3 定位 C++ 行号](https://zhuanlan.zhihu.com/p/412102389/edit#23-%E5%AE%9A%E4%BD%8Dc%E8%A1%8C%E5%8F%B7)
*   [2.4 回溯堆栈](https://zhuanlan.zhihu.com/p/412102389/edit#24-%E5%9B%9E%E6%BA%AF%E5%A0%86%E6%A0%88)
*   [2.5 寄存器值](https://zhuanlan.zhihu.com/p/412102389/edit#25-%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BC)

*   [三 Crash 应对](https://zhuanlan.zhihu.com/p/412102389/edit#%E4%B8%89-crash%E5%BA%94%E5%AF%B9)

*   [3.1 直接看 C++ 代码](https://zhuanlan.zhihu.com/p/412102389/edit#31-%E7%9B%B4%E6%8E%A5%E7%9C%8Bc%E4%BB%A3%E7%A0%81)
*   [3.2 IDA 反汇编](https://zhuanlan.zhihu.com/p/412102389/edit#32-ida%E5%8F%8D%E6%B1%87%E7%BC%96)
*   [3.3 GDB 调试服务化 crash](https://zhuanlan.zhihu.com/p/412102389/edit#33-gdb%E8%B0%83%E8%AF%95%E6%9C%8D%E5%8A%A1%E5%8C%96crash)

*   [四 案例汇编](https://zhuanlan.zhihu.com/p/412102389/edit#%E5%9B%9B-%E6%A1%88%E4%BE%8B%E6%B1%87%E7%BC%96)

*   [4.1 空指针 / 低地址指针问题](https://zhuanlan.zhihu.com/p/412102389/edit#41-%E7%A9%BA%E6%8C%87%E9%92%88%E4%BD%8E%E5%9C%B0%E5%9D%80%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98)
*   4.2 变量偏移确定
*   [4.3 this 指针为空](https://zhuanlan.zhihu.com/p/412102389/edit#42-this%E6%8C%87%E9%92%88%E4%B8%BA%E7%A9%BA)
*   [4.4 虚函数调用问题](https://zhuanlan.zhihu.com/p/412102389/edit#43-%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98)
*   [4.5 调用空函数指针](https://zhuanlan.zhihu.com/p/412102389/edit#44-%E8%B0%83%E7%94%A8%E7%A9%BA%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88)
*   [4.6 野指针以及内存问题](https://zhuanlan.zhihu.com/p/412102389/edit#45-%E9%87%8E%E6%8C%87%E9%92%88%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98)

*   [4.6.1 内存释放](https://zhuanlan.zhihu.com/p/412102389/edit#451-%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE)
*   [4.6.2 越界改写](https://zhuanlan.zhihu.com/p/412102389/edit#452%E8%B6%8A%E7%95%8C%E6%94%B9%E5%86%99)

*   [4.7 除 0 错误](https://zhuanlan.zhihu.com/p/412102389/edit#46-%E9%99%A40%E9%94%99%E8%AF%AF)
*   [4.8 系统抛 SIGABRT 中止](https://zhuanlan.zhihu.com/p/412102389/edit#47-%E7%B3%BB%E7%BB%9F%E6%8A%9Bsigabrt%E4%B8%AD%E6%AD%A2)
*   [4.](https://zhuanlan.zhihu.com/p/412102389/edit#47-%E7%B3%BB%E7%BB%9F%E6%8A%9Bsigabrt%E4%B8%AD%E6%AD%A2)9 手动抛出异常

*   [五 结束](https://zhuanlan.zhihu.com/p/412102389/edit#%E4%BA%94-%E7%BB%93%E6%9D%9F)

一 概要
----

某些模块由 C++ 语言编写，生成动态库，供 Android/IOS/PC winodws/PC linux 调用，它们对应平台下生成二进制文件格式分别是 ELF，Mach-O,PE,ELF，其中 Android 与 Linux 除了指令集不同，格式是相同，另外两种都是对应操作系统下改造的，不相互通用。PC Windows 基本作为主力开发平台，被 Visual Studio IDE Debug，自己编译的都有对应的 PDB 文件，出现问题很容易定位。PC linux 一般作服务器使用，产生 Core Dump，远程到服务器，用大名鼎鼎的 GDB 来调试，很多时间也需要 GDB 反汇编。对于移动平台的 Android 与 IOS 可以接入 bugly 来捕获 Native 的 Core Dump，或者 logcat 日志，但真机的动态库都是 strip 过的，去掉了相关的符号，需要用 bugly 上的符号重新解析，如果解析也不能直接看出问题的，可能**需要 IDA 的静态反汇编，**也是我们本文重点关注的。

二 crash 解析原理
------------

知彼知己，百战不殆，我们要了解一下基本原理，才能更好的节入，为什么能定位到函数？甚至为什么能定位到具体 C++ 行号？为什么能回溯堆栈？寄存器值有用吗？这四个问题，我们具体分析。

### 2.1 执行环境

C++ 的函数执行离不开执行环境，我们通常更关心寄存器，栈内存与堆内存三块，寄存器通常 用来执行进行计算流程、保存临时值、函数传参等；对于栈内存是我们函数调用的基础，保存函数参数，返回地址，函数局部变量栈内存；堆内存是我们动态申请的内存，比如 new，malloc 等，一些动态生成的对象内存地址在这一块。

> （关于函数执行环境我有自己实现协程一文因为要更深入讨论与使用，里面有更详细的介绍，有兴趣的可以参考。 ）

[rayhunter：人人都能学的会 C++ 协程原理剖析与自我实现](https://zhuanlan.zhihu.com/p/363971930)

### 2.2 定位函数

C++ 的函数 TestFun()编译后，一般存放在. code 代码段，会有开始长度偏移与结束长度偏移，比如记为 [Addstrar,Addfinish]。当发生 Crash 时，通过 pc 寄存器的值来映射当时可执行代码位置, 比如地值为 Addrun，注意这个 Addrun 包含了模块的加载基地址 AddMbase，如果减去了模块地基地址，就可以得到所对应的. code 地址; 其中 Addrun 所在模块的定位也比较容易，系统加载库的时间可知模块的起始与结束地址范围，这些信息 bugly 上面也会有上报，只需对比查一下模块的范围，便可知 Addrun 属于那个模块的函数，再用公式 Addreal = Addrun-AddMbase; 便可得函数地址。如果 Addreal 处于[Addstrar,Addfinish] 区间内，便可以确定崩溃就发生在函数 TestFun()中。查看 [xxxx,xxxx] 范围也能手动获取 crash 时对应的函数名称（具体函数名称我己模糊掉，有个印象就可以了）。下图所示。

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/05322a8236e29a9ca1b84931440df49b_MD5.jpg]]

下图展示部分 Android 平台下模块的起始地址，每行的开始地址区间。

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/8207faf6093523b7852bbb9edb957bfe_MD5.jpg]]

### 2.3 定位 C++ 行号

要想得到 C++ 的行号，编译的时间必须生成更多的. debug 调试段信息。工程使用 clang++ 编译，只需要加上 - g 就可以生成全量调试信息，编译器编译每个单元时，编译后的可以记录每条汇编指令对应的 C++ 行号与文件来源，但不是所有的指令都有行号的，比如编译器自己添加的指令，内置函数等都是没有 C++ 行号来源的，但这些基本不会崩溃，或者很容易辨别。对于一个编译后的函数来说，只需要查一下这条指令对应的 C++ 行号与来源，对比 C++ 源文件，这样能大大加速我们定位 crash 的效率。

除了这种快速手段，我们还可以人工通过阅读 IDA 工具下反汇编代码，对照 C++ 源码，分析出每行汇编指令与 C++ 源码映射关系，找出原因，这种手段通常比较费时费力，有时代码编译优化等级高，编译器自己内联多，会增加难度，特别是加扰后代码，更是难以阅读，但有时 C++ 源码一行有多个可能崩溃点或者不能直接看出的疑点的，我们还是需要看汇编的。

对于以前的没有开 - g，可以手动构一个带 - g 的版本，我做了一个简单映射工具，如果崩溃的地方代码内容没有更改且编译选项配置一致时，可以通过提取两者函数汇编指令集，然后再通过在线查函数反汇编，部分情景也可以解决，但这种情况下，链接时全局变量以及跳转的地址基本都会变的，要求对汇编了解比较深。 基于上面信息，下图是查询某一个地址，所对应的函数名称，函数的开始，结束地址，以及编译单元名称，该地址所对应编译单元的行号。

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/78a7c6adac71debbeaaba77d8113f862_MD5.jpg]]

### 2.4 回溯堆栈

堆栈回溯是定位 crash 时非常有用，只是这步大部分都由其它模块做了，如果发生 crash 时刚好回溯所对应的地址破坏，得到的 crash 也是不准的，失去参考意义，如果明显异常 的 crash 栈，也可以考虑一下。我们很少需要手动回溯，但原理要了解一下，每个平台下以及编译器的选择都可能不同，但原理基本一致。

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/5c7792b62dd0214c4cf67e6c50563a5e_MD5.jpg]]

上图是经典图，这图的函数开头间接要求有汇编代码：

```
push rbp;           
mov rbp,rsp;
```

这个是编译器实现的，我们不用关心。从图我们可以看出，一次函数调用，会压参（看调用约定与参数个数），再压返回地址，再压上帧 rbp，所以 rbp 是突破口。只需要访问 rbp 寄存器，便可得到上个函数调用帧的地址，地址 + 8 便是函数返回 rip 的值，rip 就能查到是那个函数，实际这里形成一个类似链表关系，然后再访问得到地址便得更上层帧地址 ，+8 便是上层 rip 返回值，以至到无法访问，便可回溯整个调用栈。注意这里的 rip 同前面说的一样，都是带模块基地址的，如果要解析函数名称，要走定位函数那一段流程。

### 2.5 寄存器值

寄存器的值是当时发生 crash 时抓到寄存器的值，不过是最后一层函数调用栈帧时的情景，通过寄存器的值，结合反汇编指令，我们时常能推断出为什么 crash，尤其是内存问题，但内存问题通常只能分析出当时为什么崩，找不到第一时间引发问题的情景。另外如果指向系统函数调用，比如 c 标准库等，通常没有源码，寄存器值也会失去参考意义，如果是业务自己的代码，通常比较有用。 下图是 bugly 截图一次崩溃的寄存器值。

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/6b055cc46dc96580b7c9dbb838e4d1f9_MD5.jpg]]

三 Crash 应对
----------

### 3.1 直接看 C++ 代码

bugly 如果带行号或者服务器版本也是带行号了，如果是基本错误直接结合调用栈与 C++ 代码推出问题点，注意看好版本号，代码要用相应的版本，大部分指针没有判断，明显的越界，除 0 可以看出来。(具体函数名与 C++ 源文件名称我己模糊处理)

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/d9cc2a2a09c9e5efb6f66a0f7ad01520_MD5.jpg]]

### 3.2 IDA 反汇编

如果 C++ 行号或者不带行号版本，需要我们手动分析时，先找到备份好的带符号的动态库，如 xxxxxx_armv8.so，注意区分一下版本，32 位 android 是 armv7，64 位是 armv8 IOS 都是 64 位, 现在是动态库，解压里面有动态库经 xxxxxx.dylib 与符号文件 dSYM

然后用 IDA 进行新建

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/f3d254c6592c15c03d7b855d6599befb_MD5.jpg]]

弹框选默认就可以，IDA 能自动识别二进制类型与指令集，然后等待加载完成，看文件大小，如果比较大，第一次加载解析过程可能需要 2 小时或者更长。 然后定位函数那小节讲过的计算真正函数代码地址，一般来说 bugly 都会已经减去了基地址，如果 bugly 没有解析出来，可以用 pc 寄存器值与模块地址自己算。然后直接按 G 键跳转

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/41b769cf806919c51c0713f070d03f83_MD5.jpg]]

接下来就是分析汇编，推断上下文，反推出每个寄存器代表的意义，这一步需要一些汇编常 用知识储备，也有一些常用技巧，平时可以 debug 时间多用用反汇编，尤其是 debug 我们 Release 的代码，无论 windows 的 VS 还是 Linux 的 GDB 或者 MAC 下的 XCode 的 LLVM 以及强大的 IDA 都可以反汇编调试，单指令调试，多看看寄存器与内存的值，都是不错的学习手段。

> （最常见的一些知识还可以参考原来的文章。IDA 反汇编静态调试 Android 平台 C++ 的 so 文件 Crash 实战与总结 ）

[rayhunter：IDA 反汇编静态调试 Android 平台 C++ 的 so 文件 Crash 入门](https://zhuanlan.zhihu.com/p/270912347)

### 3.3 GDB 调试服务化 crash

模块同时在远端 Linux 的服务器被调用，有时也能触发模块的 crash，Linux 当然是 GDB 用的多，GDB 指令比较友好，记住常用指令就可以了，能看懂汇编，不过默认 AT&T 汇编，跟 intel 汇编形式略有不同，调试问题基本就难度不大，记不住知道有这条也行，很可以查出来，我记录一些常用供参考。

> **断点**  
> b core.h:41  
> b test.cpp:48 if(aiTest == 18 && biTest == 19)  
> 条件断点，if (xxx), 其中 if 与 (最好有空格)  
> b 'helloworld::hellofunction' 对函数进行设定地址  
> b _0x222222243 对指令地址进行设断点_  
> **_断点操作_**  
> _info b_  
> _del 1/2/3_  
> **_反汇编_**  
> _disassemble_  
> _disassemble 'MyProcessor::ActijonHelper'_  
> _x /10i $pc 显示 10 条当前反汇编_  
> **_变量_**  
> _p_ infoPtr  
> p $rsi  
> p info  
> p &aiTest  
> p global::GetTest()  
> p /x _(unsigned long long_)0x7fffec8ed320 按 16 进制的 ulong long 查看 0x7fffec8ed320 内存里面的值  
> **信息查看**  
> info args  
> info registers  
> p $rsi  
> **监视**  
> rwatch _(long long_)0x7fffff22f 读  
> watch _(long long_)0x7fffff22f 写  
> awatch _(long long_)0x7fffff22f 读写  
> rwatch i if i == 5  
> watch _(int_)0x7fffff22f if _(int_)0x7fffff22f == 109999  
> **栈帧**  
> bt  
> bt full 3 全量  
> f 2  
> f 0  
> **操作**  
> s 单指令  
> si 单指令入  
> n 不进入  
> si 5 执行 5 次单指令  

四 案例汇编
------

有了上面信息，我们讨论一下常见的问题，以便更快的定位。不过说一下，不是所有 crash 都是能解的，尤其是一些偶发的内存问题，就算我们看完关键地方的汇编，也只能知道崩溃那一时刻是什么原因，但这个原因基本不是内存破坏的第一现场，基本上很早内存就被破坏了。总的来说内存问题一般会报 **SIGSEGV** 段错误，通常我们要和两种打交道，**SEGV_MAPERR 与 SEGV_ACCERR**，其中 maperr 一般是访问这块内存所对应内存页并没有真正在应用中有映射，比如空指针，低地址指针，地址错误，内存已经被系统回收以及溢出等。对于 accerr 是这块内存在应用中有映射，但没有权限，比如试图修改只读的区域。 在 64 位系统中，一般 48bit 0x00007fffffffffff 分界，用户和系统内核，通过这一范围判断，也能帮我们处理不少内存异常问题。

> // 48bit memory read/write  
> // user 0x0000000000000000~0x00007fffffffffff  
> // ker 0xFFFF800000000000~ 0xFFFFFFFFFFFFFFFF

### 4.1 空指针 / 低地址指针问题

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/80e07b95944d816117476a7bcd56bbb6_MD5.jpg]]

通常来说只有一两级内存跳转访问我们看 C++ 代码基本都能看出来，但如果在一行 C++ 代码中遇到连续访问型还是不能看出来，需要看汇编来准确定位以及变量的偏移地址来确认。如 pkAddr1->pkAddr2->pkAddr3->pkAdd4 = 100; 这种任何一个指针都可能出问题。假如 12BA8BC 处发生 crash，看一眼基本就可以猜出空指针或者地址非法，因为从 X20+12 的值所对应的内存区域内容，放到 w0 中，发生了从内存到寄存器的操作，这时就要小心，去 bugly 看一下 x20 寄存器的值，一般来说都是非法内存，0 地址或者低地址居多，有时是明显被破坏的内存地址。

**4.2 变量偏移确定**

接上面的，对于连续访问，汇编层面都是偏移不能直接看出来，怎么确定是那个变量，就要看变量在类中偏移值了。比如上图中 [x20,#0xc]，就是等于 x20 地址所对应的结构再加上 12 字节，我们只要查 C++ 下一级访问的变量是不是相对父级偏移 12 即可。对于开启了 - g 的带全量 debug 信息的符号来说，可以在 IDA 本地型中（shift+F1）中直接搜萦结构体或者类名，里面会变量的偏移值.

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/328948ec11e3d55dba17bb8277a78fb4_MD5.jpg]]

查到结构体或者类名后，直接双击导入，我们就可以得到这个结构成员的具体的偏移信息了。，如下图所示，前面是偏移值，0xc 偏移的是 demBuffPos。

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/2542f9c790f1e13480ba51b282eb05f1_MD5.jpg]]

### 4.3 this 指针为空

对于 C++ 来说，this 指针为空太常见了，比如访问成员，访问虚表，一些函数传参都要用到 this 指针，这些相对比较容易理解，它实际也是第一种空指针，比较容易推断。不过有一种类型我们要注意，对于 C++ 的成员函数来说，第一个参数为隐含的 this 指针，如果一个类己释放，同时将指针也置空了，或者没有创建，也就是 this 指针为空，但我们还是可以调其成员函数的，只是会将第一个参数传为 nullptr 了，如果**巧好这个成员函数没有虚函数调用，也没有成员访问，是不会崩溃**，这点在查看栈的时间有一定的误导性。

### 4.4 虚函数调用问题

C++ 的虚函数是运行时，编译期无法确定，也就是无法编译成调用一个固定的偏移地址，在运行时通常分为两条汇编指令来完成，第一步得到虚表地址，第二步 call 虚表地址下对应函数偏移的具体代码段地址，这样就很容易出现内存问题导致 crash，除了前面说的 this 指针为空带来影响，更多的由于**越界，溢出或者内存某种原因破坏**，刚好写坏了 this 地址里面内容，导致虚表不能真正指向. rodata 有效值，变成一个无意义的值，通常引发 SIGSEGV 段错误。 下图是一个示例：

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/7fd18c9bcd2a02ad52bb60a604cb4afa_MD5.png]]

12BAEFC 地址对 obj 进行 this 访问，拿到虚表地址 12BAF04 地址对虚表进行偏移 0x50 访问，也就取第 10 个虚函数代码段地址，以便接下一条指令进行调用，这时通常会产生 crash，一般 x8 是非法地址，这时就要查看 bugly 上记录的寄存器信息来确认我们的推论。如果是日志就查看 logcat 文件记录，如果是调试状态，直接看寄存器的值。

### 4.5 调用空函数指针

如果调用的函数指针为空或者虚函数由于虚表被破坏，刚好得到函数地址为 0，就会产生类似堆栈，以 lr 为解析，而非平时 pc 寄存器，这时堆栈极在可能无法回溯。

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/c7f70fc6354305b390ef5f51f00695a3_MD5.png]]

对应 C++ 的代码的

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/4282f16748b807e99835d2b6212cef50_MD5.jpg]]

用前面说的 IDA 反汇编打开动态库

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/422f13297dd439e41bc0b45095de33c4_MD5.png]]

从 bugly 查 Crash 的寄存器，R0 是我们模糊掉的对象，R2 为虚函数 update 的代码段地址，可以看出模糊掉的对象地址内存是合法的，模糊掉的对象的内存被破坏，导致虚表无法得法得到正确的数据，跳转虚函数 update 失败。

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/98398d0074e2f8240909d09d937edf5c_MD5.jpg]]

### 4.6 野指针以及内存问题

在 C++ 中野指针或者其他情况引发内存破坏问题也是非常常见，表现为上报 SIGSEGV 段错误。从汇编指令上看是寄存器与内存相互交互产生的，所以看到有内存操作的指令，就要警惕起来，会不会出现内存改写错误或者已释放。如果一个内存已经释放，可能回池或者被系统回收，再访问都极大可能引发 crash 的风险，在自己的内存模块中，内存托管的通常释放后每个字节被置为 0xdd，也是一个明显的标识。从汇编寄存器上来说，如果是野指针一般对应的寄存器地址看起来非常合法，如果是内存被溢出，越界或者非法改写，对应的寄存器地址可能就比较乱，这些都是信号。

### 4.6.1 内存释放

C++ 代码

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/e0061a00fae45a4f76a4556acd118dea_MD5.png]]

反汇编

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/5fa6ec4fe96dc5d308124c8d9880da4f_MD5.png]]

查看 bugly 上的寄存器

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/410e751d6ba29c33590734bea637981a_MD5.jpg]]

pObj 内存为 0xdddddddddddddddd, 内存已经释放过了，所以 Crash

### 4.6.2 越界改写

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/87f090f83c860a05803feebc2819e1d0_MD5.jpg]]

反推 C++ 代码，可知 auto xxxx1 = xxxxx2->xxxx3 的容器内存被破坏了，结合 bugly 看 r9 是个非法的值，发现 r9 的最高位被改动 01，这不是用户空间，极大可能是内存有越界改写。

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/ed5d885d241b6f87450cf355d28efe60_MD5.jpg]]

### 4.7 除 0 错误

除 0 错误是一种常见的算术错误 ，有堆栈的话，可以直接看上层函数调用栈就可以了。不过 PC 平台指令集有现成的除法指令，比如 idiv，但到了 arm 架构体系上是没有除法硬件运算的，被编译器托管为内部函数实现，函数名为 **aeabi_idiv0 或者** aeabi_ldiv0，对于除 0 抛不抛异常，取决于函数的不同实现，通常会触发 SIGFPE 信号。可以见 arm 架构 ABI 的解释。不过 arm64 有除法指令 sdiv，可见链接：[https://developer.arm.com/documentation/dui0802/a/SDIV](https://link.zhihu.com/?target=https%3A//developer.arm.com/documentation/dui0802/a/SDIV)

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/bafbd4baf31ed96e1e925601346ba9e8_MD5.jpg]]

对于业务来说比较简单，我们看一下 bugly 抓取截图，堆栈第一行是 c 标准库终止，第二行就是前面说的内部函数，第三行就是业务触发点。

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/53eac52a5e7588760e4593702c767690_MD5.png]]

查看 il2cpp 对应的源码，的确是有除 0 错误 ，代码加上保护即可

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/5a534a40b31efd731125f68eabc3adf4_MD5.jpg]]

### 4.8 系统抛 SIGABRT 中止

这是一个非常容易遇到的 crash，会触发 SIGABRT 信号，一般调用 abort，assert 会触发。除去个别我们手动调用检测，通常来说都是业务函数与系统标准库交互时，被系统库检测到参数或者数据异常，调用到的，从堆栈上来看通常最后面都是标准库，且寄存器这时是标准库内容，失去意义，这种情况一般都要根据堆栈业务层最后调用，是不是存在数据非法，比如 **memcpy，重复释放内存，堆越界，网络底层 api 操作**等，都容易触发。不过部分可能连业务层代码都没有获得，基本上很难定位。

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/a935fc79ca6b914b8f2feb68a273668f_MD5.jpg]]

这一例对应 C# 源码是，堆栈第 9 行由于编译器自行优化部分内联，增加我们定位的难度，对应红框代码，暂时不方便展示，己打码。

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/e38e0c5881940fd96ca543fd8e13f622_MD5.jpg]]

继续分析 C# 代码，到这里要转到其它代码中，这里代码不方便展示，只说最后结论。后面代码就是回收销毁内存，**bugly 上报 SIGABRT，arbt 重复释放内存或者释放不合法地址，堆越界以及 assert 断言错误**，结合堆栈这里推测第一种重复释放内存或者释放不合法地址可能性比较大

### 4.9 手动抛出异常

这种比较简单，一般是我们业务层自己主动抛出异常，防上问题继续扩散，是一种保护性策略，直接看堆栈就可以解出，**通常会抛出 SIGTRAP 信号或者 SIGILL**。 从 C++ 代码实现也可以看出，调用编译器内置函数__builtin_trap() 即可，在 windows 平台可以调用内置的____debugbreak();_

看一个实例，对于 sqrt 计算，要求非负，如果发现参数为负，手动抛出异常。

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/0b26d2be5dd643299411f851e6d29eee_MD5.jpg]]

这种就看堆栈即可，可以看一下 C++ 代码验证一下

![[assets/img/2024-1-2-C++中Crash定位原理与常见案例反汇编分析/41a805df64b4ed2e8b8423b658babac0_MD5.jpg]]

五 结束
----

crash 定位有的容易，有的很麻烦，深入定位常会涉及的一些常用汇编知识，需要一定的积累。某些情景，比如一些内存问题，特别依赖环境，出现问题都不是第一出错现场，不能复现基本无解，只要能复现，基本都能定位出来，只不过可能由于 Release 下优化以及需要汇编协助，可能较麻烦。

如果喜欢的麻烦点赞，收藏加关注，谢谢！

本文版本为 rayhunter 所有，未经许可，禁止转载。