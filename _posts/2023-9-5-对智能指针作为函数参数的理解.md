> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.zhihu.com](https://www.zhihu.com/question/435860006) 

看到挺多类似问题，其实可以参考 [C++ Core Guidelines](https://link.zhihu.com/?target=https%3A//isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines%23S-resource) 来解释你的疑惑的。

![[assets/img/2023-9-5-对智能指针作为函数参数的理解/099c5443ce35ae788514409bafb79a44_MD5.jpg]]

上述表中相应 Rule 来自 [C++ Core Guidelines](https://link.zhihu.com/?target=https%3A//isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines%23S-resource)，在 [C++ Core Guidelines](https://link.zhihu.com/?target=https%3A//isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines%23S-resource) 中智能指针这里没有关于[右值引用](https://www.zhihu.com/search?q=%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2591848267%7D)相关的介绍，这里补充一下吧。

&& 属于右值引用，一般用在两个地方：**移动语意，完美转发。 其中较典型的是用在[移动构造函数](https://www.zhihu.com/search?q=%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2591848267%7D)中。

下面来说说，什么时候使用[引用类型](https://www.zhihu.com/search?q=%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2591848267%7D)，什么时候使用 const&，什么时候使用 value 传参 (**针对智能指针**)

[C++ Core Guidelines](https://link.zhihu.com/?target=https%3A//isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines%23S-resource) 的 R.30 有如下一句话

> **Take smart pointers as parameters only to explicitly express lifetime semantics**

换句话说，**如果你传递一个智能指针作为函数参数，但是在这个函数内你仅仅想使用智能指针的底层资源，那么在这种场景下你应该使用一个 raw pointer(裸指针) 或者一个引用作为函数参数，因为此刻你并不需要智能指针[生命周期](https://www.zhihu.com/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2591848267%7D)相关语意。**

关于代码示例，此处就略了

再来看看关于 std::unique_ptr 作为参数相关的规则

> **R.32: Take a unique_ptr<widget> parameter to express that a function assumes ownership of a Widget**

**也即，当你的函数参数为 unique_ptr 值类型时，表明此刻你将 widget 的资源所有权转移到该函数内**

> **R.33: Take a unique_ptr<widget>& parameter to express that a function reseats the Widget**

**也即，当你的参数为 unique_ptr 引用类型时，表明此刻你将在函数中重新设置 widget 相关资源。**

来看看 std::shared_ptr 作为函数参数时相关的规则

> **R.34: Take a shared_ptr<widget> parameter to express that a function is part owner**

**也即，函数参数为 shared_ptr 值类型时，表示函数是相应资源的一个所有者**

> **R.35: Take a shared_ptr<widget>& parameter to express that a function might reseat the shared pointer**

**也即，函数参数为 shared_ptr 引用类型时，表明此刻你可能在函数中重新设置共享指针**

> **R.36:Take a const shared_ptr<widget>& parameter to express that it might retain a reference count to the object**

**也即，采用 [const shared_ptr](https://www.zhihu.com/search?q=const%20shared_ptr&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2591848267%7D) 引用参数时，表明你想要保持对象的[引用计数](https://www.zhihu.com/search?q=%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2591848267%7D)不变**

上述三个参数的相应函数声明如下

```
void share(std::shared_ptr<Widget>);
void reseat(std::shared_ptr<Widget>&);
void mayShare(const std::shared_ptr<Widget>&);
```

具体来说一下上述三个函数声明帮助理解吧

**void share(std::shared_ptr<Widget> ):**

在函数的生命周期中，我是 Widget 的共享所有者。 在函数的开头，我增加了引用计数； 在函数结束时，我减少引用计数； 因此，只要我使用 Widget，它就会一直存在。

**void reseat(std::shared_ptr<Widget>&):**  
  
我不是 Widget 的共享所有者，因为我不更改引用计数器。 我不能保证 Widget 在函数执行期间一直存在，但我可以重新设置资源。

**void mayShare(const std::shared_ptr<Widget>&):**  
  
我只租借资源。 我既不能延长资源的生命周期，也不能重新设置资源。 此刻，最好使用指针 (Widget*) 或引用 (Widget&) 作为参数。  
  
  
**大概就这些，具体怎么用，还是需要根据你自己的场景，具体分析和作相应抉择。**  

[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-resource](https://link.zhihu.com/?target=https%3A//isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines%23S-resource)

 ![[assets/img/2023-9-5-对智能指针作为函数参数的理解/9f4450e038cac45e604b2be9cc01e662_MD5.png]]萧叶轩

首先，string 不应该套一层智能指针，其次，智能指针传递应该用值为参数，而不是引用，或者直接把内部指针作为参数。![[assets/img/2023-9-5-对智能指针作为函数参数的理解/eafe0930483b833e59b5ef4803acad8b_MD5.jpg]]指标王中王![[assets/img/2023-9-5-对智能指针作为函数参数的理解/f6ab48cd7e3f4247241997c138769536_MD5.jpg]]股師收割机